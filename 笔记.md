启动设置:
    打开启动类配置,在working directory设置选择 $MODULE_WORKING_DIR$ 即可
    
    
整体架构:   
  Server
    Service []
  Service:
    Connector[] : 监听socket请求,对请求进行编码,将请求转发给线程池
    Container(Engine): 容器
    ArrayList<Executor>
  Connector:
    ProtocolHandler: 接收/响应/解析http请求 , 实现类为Http11NioProtocol
  ProtocolHandler(Http11NioProtocol):
    AbstractEndPoint: 内部类监听连接请求Acceptor(1个线程), 处理以及注册线程Poller(最大2个线程) 
        Executor: 线程池,核心线程大小为10,最大为200,负责处理请求所有请求   
    
  Container代表一个容器,这在tomcat中有如下: Engine,Host,Context,Wrapper
容器之间的关系如下:
  Engine:
    Host[]
  Host:
    Context[]
  Context:
    Wrapper[]
  Wrapper: 这是最小的容器,已经没有子容器了,其实就是一个Servlet容器
    Servlet   
    
  类加载器:
      commonLoader (UrlClassLoader)
      catalinaLoader
      sharedLoader
      默认情况下,三个都是同一个类加载器(同一个实例)
      线程上下文设置为 catalinaLoader
      
  catalinaLoader类加载器加载Catalina
  设置Catalina实例的父加载器为sharedLoader
  设置Catalina的await为true, 这个await是阻塞,等待接受关闭命令
  执行Catalina.load():
    initNaming() :　设置命名相关系统变量
    
类似Netty:
    Acceptor线程:  1个 , 监听连接事件 , 将连接事件构建成PollerEvent任务,放入到 SynchronizedQueue<PollerEvent> events队列中
    Poller线程: 最大2个 ,
          职责: 1.从events任务队列不断拉取任务执行; 
                2.执行的任务有如下: 将当前连接注册到当前线程的selector中或者是将当前连接从当前线程中的selector移除;
                3.除了执行events的任务外,还会不断监听已加入连接的读写断开等事件;将监听的数据包装成Runnable(SocketProcessorBase实现类),提交到线程池
    请求逻辑线程池: 

 
 设计模式:
    工厂模式: 线程工厂TaskThreadFactory
    模板模式: SocketProcessorBase
    
     
    